/* Copyright Â© 2023 Ernie Rael. All rights reserved */

// This file is generated by a script: scipts/extract_functions
// from astrolog's express.cpp which is copyrighted by:
// Walter D. Pullen (Astara@msn.com, http://www.astrolog.org/astrolog.htm)

package com.raelity.astrolog.castro.tables;

import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;

import com.raelity.astrolog.castro.antlr.AstroParser.ExprFuncContext;
import com.raelity.astrolog.castro.antlr.AstroParser.Func_callContext;
import com.raelity.astrolog.castro.mems.AstroMem;
import com.raelity.astrolog.castro.mems.Macros;
import com.raelity.astrolog.castro.mems.Switches;

import static com.raelity.astrolog.castro.Error.FUNC_CASTRO;
import static com.raelity.astrolog.castro.Util.lookup;
import static com.raelity.astrolog.castro.Util.macroSwitchFuncArgs;
import static com.raelity.astrolog.castro.Util.reportError;

public class Functions
{
public static final String FUNC_ID_SWITCH = "switch";
public static final String FUNC_ID_MACRO = "macro";

    /**
     * In addition to astrolog functions, there can be magic castro functions;
     * this represents a specific function, including it's name,
     * and how to generate code for it.
     */
    abstract public static class Function
    {
    public abstract String name();
    public abstract int narg();
    public abstract boolean error();
    /** Check for special func args; returns true if OK and no further
     * checking needed. Typically meaningfull where unusual arguments
     * are expected, like switch/macro name. A false return doesn't
     * mean there's a problem, only that further checking is expected.
     */
    public abstract boolean checkReportSpecialFuncArgs(Func_callContext ctx);
     /* @return null for variable, else macro/switch memSpace */
    public abstract AstroMem targetMemSpace();
    public abstract StringBuilder genFuncCall(
            StringBuilder sb, ExprFuncContext ctx, List<String> args);

    @Override
    public String toString()
    {
        return "Function{name:" + name() + '}';
    }

    }

public static void addFunction(Function f, String... aliases)
{
    if(functions.funcsModifiableMap.putIfAbsent(
            f.name().toLowerCase(Locale.ROOT), f) != null)
        throw new IllegalArgumentException();
    for(String alias : aliases) {
        functions.addAlias(alias, f.name());
    }
}

/** dummyFunction is a singleton DummyFunction */
private static Function dummyFunction = new DummyFunction();

/**
 * @return Function for the name
 */
// TODO: extend to handl magic functions
// TODO: return replace function (do translate() here)
public static Function get(String funcName)
{
    String lcName = funcName.toLowerCase(Locale.ROOT);
    String alias = functions.aliasFuncs.get(lcName);
    if(alias != null)
        lcName = alias;
    Function f = functions.funcs.get(lcName);
    return f != null ? f : dummyFunction;
}

// TODO: should this be Function.equals(Function)?
public static boolean eqfunc(String s1, String s2)
{
    Objects.nonNull(s1);
    Objects.nonNull(s2);
    return s1.equalsIgnoreCase(s2);
}

public static boolean funcSwitchOrMacro(String funcName)
{
    return eqfunc(FUNC_ID_SWITCH, funcName) || eqfunc(FUNC_ID_MACRO, funcName);
}

// Would like a read only unioun of regular maps and unknown maps.
// https://stackoverflow.com/questions/66428518/java-read-only-view-of-the-union-of-two-maps;
// But, unknown only needs to be a set; since unkown rest of info is derived.

/** Track a special function (unknown or magic);
 * further inquiries about this
 * name will not return null and narg returns 0. 
 * Keep a set of special function names. And add the unknown
 * to the main map to keep the rest of the code simple.
 */
public static void recordCastroFunction(String funcName)
{
    String lc = funcName.toLowerCase(Locale.ROOT);
    if(functions.funcs.containsKey(lc) || functions.unknownFuncs.containsKey(lc))
        throw new IllegalArgumentException(funcName);
    functions.unknownFuncs.put(lc, null);
    functions.add(lc, 0, "R_");
}

public static boolean isCastroFunction(String funcName)
{
    return functions.unknownFuncs.containsKey(funcName.toLowerCase(Locale.ROOT));
}

// singleton
private static final Functions functions = new Functions();

private final Map<String, Function> funcsModifiableMap;
private final Map<String, Function> funcs;
private final Map<String,String> aliasFuncs;
private final Map<String,Object> unknownFuncs;

private Functions() {
    // ~500 items, 700 entries, load-factor .72
    // keep modifiable funcs around to add unknown func.
    this.funcsModifiableMap = new HashMap<>(700);
    this.funcs = Collections.unmodifiableMap(funcsModifiableMap);
    this.unknownFuncs = new HashMap<>();
    this.aliasFuncs = new HashMap<>();
    new AstrologFunctions(this).createEntries();
    // Provide "evaluate both sides" semantics for "?:" if wanted.
    addAlias("QuestColon", "?:");
    addAlias("AssignObj", "=Obj");
    addAlias("AssignHou", "=Hou");
}

private void addAlias(String castroName, String astroName)
{
    if(aliasFuncs.putIfAbsent(castroName.toLowerCase(Locale.ROOT),
                              astroName.toLowerCase(Locale.ROOT)) != null)
        throw new IllegalArgumentException();
}

/** key is lower case. Save original name and nargs. */
void add(String funcName, int narg, String types)
{
    Objects.nonNull(types);
    funcsModifiableMap.put(funcName.toLowerCase(Locale.ROOT),
                           new AstrologFunction(funcName, narg));
}

    private static class DummyFunction extends Function
    {
    @Override
    public StringBuilder genFuncCall(StringBuilder sb, ExprFuncContext ctx,
                                     List<String> args)
        { sb.append("#DummyFunctionCall#");  return sb;}
    @Override public String name() { return "#DummyFunction#"; }
    @Override public int narg() { return 0; }
    @Override public boolean error() { return true; }
    @Override public boolean checkReportSpecialFuncArgs(Func_callContext ctx) { return false; }
    @Override public AstroMem targetMemSpace() { return null; }
    }

    /** Astrolog builtin function */
    // TODO: equals? Only need to check funcName
    static class AstrologFunction extends Function
    {
    private final String funcName;
    private final int narg;

    AstrologFunction(String funcName, int narg)
    {
        this.funcName = funcName;
        this.narg = narg;
    }

    @Override public String name() { return funcName; }
    @Override public int narg() { return narg; }
    @Override public boolean error() { return false; }

    @Override
    public AstroMem targetMemSpace()
    {
        return eqfunc(FUNC_ID_SWITCH, funcName) ? lookup(Switches.class)
               : eqfunc(FUNC_ID_MACRO, funcName) ? lookup(Macros.class)
                 : null;
    }

    @Override
    public boolean checkReportSpecialFuncArgs(Func_callContext ctx)
    {
        boolean checksCompleteAndGood;
        if(funcSwitchOrMacro(ctx.id.getText())) {
            AstroMem memSpace = targetMemSpace();
            checksCompleteAndGood = macroSwitchFuncArgs(ctx, memSpace);
            
            //List<ParseTree> l = List.copyOf(expr2Lvals(ctx.args.get(0)));
            //if(memSpace != null
            //        && !l.isEmpty()
            //        && l.get(0) instanceof LvalMemContext
            //        && memSpace.getVar(ctx.args.get(0).getText()) == null) {
            //    reportError(ctx, "'%s' is not a defined %s",
            //                     ctx.args.get(0).getText(),
            //                memSpace.memSpaceName.equals(MEM_SWITCHES)
            //                    ? "switch" : "macro");
            //    checksCompleteAndGood = false;
            //} else
            //    checksCompleteAndGood = true;
        } else
            checksCompleteAndGood = false;
        return checksCompleteAndGood;
    }

    @Override
    public StringBuilder genFuncCall(
            StringBuilder sb, ExprFuncContext ctx, List<String> args)
    {
        if(Ops.isAnyOp(funcName))
            reportError(FUNC_CASTRO, ctx.fc.id,
                        "using castro operator '%s' as a function",
                        ctx.fc.id.getText());
        sb.append(funcName).append(' ');

        for(String arg : args) {
            sb.append(arg);
        }
        return sb;
    }
    }

}
