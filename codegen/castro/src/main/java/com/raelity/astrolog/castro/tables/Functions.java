/* Copyright Â© 2023 Ernie Rael. All rights reserved */

// This file is generated by a script: scipts/extract_functions
// from astrolog's express.cpp which is copyrighted by:
// Walter D. Pullen (Astara@msn.com, http://www.astrolog.org/astrolog.htm)

package com.raelity.astrolog.castro.tables;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;

import org.antlr.v4.runtime.Token;

import com.raelity.astrolog.castro.Pass3;
import com.raelity.astrolog.castro.antlr.AstroParser.ExprFuncContext;
import com.raelity.astrolog.castro.antlr.AstroParser.Func_callContext;
import com.raelity.astrolog.castro.mems.AstroMem;
import com.raelity.astrolog.castro.mems.AstroMem.Var;
import com.raelity.astrolog.castro.mems.Macros;
import com.raelity.astrolog.castro.mems.Registers;
import com.raelity.astrolog.castro.mems.Switches;

import static com.raelity.astrolog.castro.Error.*;
import static com.raelity.astrolog.castro.Util.lookup;
import static com.raelity.astrolog.castro.Util.macroSwitchFuncArgs;
import static com.raelity.astrolog.castro.Util.reportError;

public class Functions
{
public static final String FUNC_ID_SWITCH = "switch";
public static final String FUNC_ID_MACRO = "macro";

private record FunctionUsage(Token id, int narg) {}

/**
 * isConst - False means this given call is not a constant, ignore all else.<br>
 * realVal - constant value of the specific function call<br>
 * displayVal - user specified value of the specific function call<br>
 */
public static record FunctionConstValue(boolean isConst, int realVal, int displayVal){};
public static FunctionConstValue NOT_CONST_VALUE = new FunctionConstValue(false, 0, 0);

private static void reportFuncNargError(Object ctx_or_token,
                                        String name, int expect, int result)
{
    reportError(FUNC_NARG, ctx_or_token,
                "function '%s' argument count, expect %d not %d",
                name, expect, result);
}

private static void reportUserFuncNargError(Object ctx_or_token,
                                            String name, int expect, int result)
{
    reportError(ctx_or_token,
                "\"%s\" expects %d arguments for macro function call not %d",
                name, expect, result);
}

private static String lc(String s)
{
    return s.toLowerCase(Locale.ROOT);
}

    /**
     * The base class for any function; codegen and checking.
     * Could be regular Astrolog function, special func like switch/macro,
     * castro function. User defined function (really a macro).
     */
    abstract public static class Function
    {
    protected final String funcName;
    protected final int narg;

    public Function(String funcName, int narg)
    { this.funcName = funcName; this.narg = narg; }

    public final String name() { return funcName; }
    public final int narg() { return narg; }

    /** Invalid means that this Function definition itself has a problem;
     * it can't be used.
     */
    public boolean isInvalid() {
        return false;
    }

    public boolean isBuiltin() {
        return true;
    };

    public boolean isUnknown() {
        return false;
    }

    List<FunctionUsage> getReferences() {
        return Collections.emptyList();
    }

    public void addReference(Token id, int narg) {
        // typically don't care about references.
    }

    /** Check for special func args; returns true if no further
     * checking needed, doesn't mean there's not an error.
     * Typically meaningfull where unusual arguments
     * are expected, like switch/macro name. A false return doesn't
     * mean there's a problem, only that further checking is expected.
     */
    public boolean isDoneReportSpecialFuncArgs(Func_callContext ctx)
    {
        return false;
    }

     /* @return null for variable, else macro/switch memSpace */
    public AstroMem targetMemSpace() {
        return null;
    }

    /**
     * Check for correct number of args.
     * This impl assumes expr args; see override in StringFunction,
     * for string args.
     * @return true if nargs is OK, else false if bad num args.
     */
    public boolean checkReportArgs(Func_callContext ctx)
    {
        if(ctx.args.size() != narg()) {
            reportFuncNargError(ctx, ctx.id.getText(), narg(), ctx.args.size());
            return false;
        }
        return true;
    }

    /**
     * This returns a constant result of a given function invocation.
     * The default is not constant, this may be overriden for functions
     * that are constant given context.
     * <p>
     * NOTE that if being a constant is dependent on
     * an allocated addresses, then this must return false before isAllocFrozen()
     * is true.
     */
    public FunctionConstValue constValue(ExprFuncContext ctx) {
        return NOT_CONST_VALUE;
    }

    /** generate code for this function call */
    public abstract StringBuilder genFuncCall(
            StringBuilder sb, ExprFuncContext ctx, List<String> args);

    @Override
    public String toString()
    {
        return "Function{name:" + name() + '}';
    }

    @Override
    public int hashCode()
    {
        int hash = 3;
        hash = 79 * hash + Objects.hashCode(this.funcName);
        return hash;
    }

    @Override
    public boolean equals(Object obj)
    {
        if(this == obj)
            return true;
        if(obj == null)
            return false;
        if(getClass() != obj.getClass())
            return false;
        final Function other = (Function)obj;
        return Objects.equals(this.funcName, other.funcName);
    }

    } /////////// class Function


    abstract public static class StringArgsFunction extends Function
    {
    public StringArgsFunction(String funcName, int narg)
    {
        super(funcName, narg);
    }

    @Override
    public boolean checkReportArgs(Func_callContext ctx)
    {
        if(ctx.strs.size() != narg()) {
            reportFuncNargError(ctx, ctx.id.getText(), narg(), ctx.strs.size());
            return false;
        }
        return true;
    }

    } /////////// class StringArgsFunction

///////////////////////////////////////////////////////////////////////////////
//
// public methods to work with functions
//

/**
 * If unknown function is a warning,
 * then convert any unknown functions to AstrologFunctions.
 */
public static void cleanupAfterFirstPass()
{
    for( Entry<String, Function> e : functions.funcsModifiableMap.entrySet()) {
        Function f = e.getValue();
        if(f.isUnknown()) {
            for(FunctionUsage ref : f.getReferences()) {
                if(f.narg() == ref.narg())
                    reportError(FUNC_UNK, ref.id(), "unknown function '%s'", f.name());
                else
                    reportError(ref.id(),
                                "unknown function '%s', args expect %d not %d",
                                f.name(), f.narg(), ref.narg());
            }
            e.setValue(new AstrologFunction(f.name(), f.narg()));
        }
    }
}

public static void addFunction(Function f, String... aliases)
{
    if(functions.funcsModifiableMap.putIfAbsent(lc(f.name()), f) != null)
        throw new IllegalArgumentException();
    for(String alias : aliases) {
        functions.addAlias(alias, f.name());
    }
}

public static void addUserFunction(String name, List<String> args)
{
    Function fAlready = Functions.get(name);
    if(fAlready.isUnknown()) {
        for(FunctionUsage reference : fAlready.getReferences()) {
            if(reference.narg() != args.size()) {
                // The macro was used with a different arg count than
                // the declaration. Uses of this macro must get an error.
                reportUserFuncNargError(reference.id(),
                                        name, args.size(), fAlready.narg());
            }
        }

        // Take the unknown function out of the table.
        functions.funcsModifiableMap.remove(lc(name));
    }
    UserFunction f = new UserFunction(name, args);
    if(functions.funcsModifiableMap.putIfAbsent(lc(f.name()), f) != null)
        throw new IllegalArgumentException();
}

public static void addUnkownFunction(Token id, int narg)
{
    UnknownFunction f = new UnknownFunction(id, narg);
    if(functions.funcsModifiableMap.putIfAbsent(lc(f.name()), f) != null)
        throw new IllegalArgumentException();
}

/** dummyFunction is a singleton DummyFunction */
private static Function dummyFunction = new DummyFunction();

/**
 * @return Function for the name
 */
public static Function get(String funcName)
{
    String lcName = lc(funcName);
    String realName = functions.aliasFuncs.get(lcName);
    if(realName != null)
        lcName = realName;
    Function f = functions.funcs.get(lcName);
    return f != null ? f : dummyFunction;
}

// TODO: should this be Function.equals(Function)?
public static boolean eqfunc(String s1, String s2)
{
    Objects.nonNull(s1);
    Objects.nonNull(s2);
    return s1.equalsIgnoreCase(s2);
}

public static boolean funcSwitchOrMacro(String funcName)
{
    return eqfunc(FUNC_ID_SWITCH, funcName) || eqfunc(FUNC_ID_MACRO, funcName);
}

// Would like a read only unioun of regular maps and unknown maps.
// https://stackoverflow.com/questions/66428518/java-read-only-view-of-the-union-of-two-maps;
// But, unknown only needs to be a set; since unkown rest of info is derived.

// singleton
private static final Functions functions = new Functions();

private final Map<String, Function> funcsModifiableMap;
private final Map<String, Function> funcs;
private final Map<String,String> aliasFuncs;

private Functions() {
    // ~500 items, 700 entries, load-factor .72
    // keep modifiable funcs around to add unknown func.
    this.funcsModifiableMap = new HashMap<>(800);
    this.funcs = Collections.unmodifiableMap(funcsModifiableMap);
    this.aliasFuncs = new HashMap<>();
    new AstrologFunctions(this).createEntries();

    // TODO: Replace Macro()/Switch()
    replaceWith(new MacroFunction());
    replaceWith(new SwitchFunction());

    // Provide "evaluate both sides" semantics for "?:" if wanted.
    addAlias("QuestColon", "?:");
    addAlias("AssignObj", "=Obj");
    addAlias("AssignHou", "=Hou");
}

private void addAlias(String castroName, String astroName)
{
    if(aliasFuncs.putIfAbsent(lc(castroName), lc(astroName)) != null)
        throw new IllegalArgumentException();
}

// Replace an existing function by the param function;
// based on the function name.
private void replaceWith(Function f)
{
    // Something should already be there
    if(funcsModifiableMap.put(lc(f.name()), f) == null)
        throw new IllegalArgumentException();
}

/** key is lower case. Save original name and nargs. */
void add(String funcName, int narg, String types)
{
    Objects.nonNull(types);
    funcsModifiableMap.put(lc(funcName), new AstrologFunction(funcName, narg));
}

    private static class DummyFunction extends Function
    {
    public DummyFunction()
    { super("#DummyFunction#", 0); }

    @Override
    public StringBuilder genFuncCall(StringBuilder sb, ExprFuncContext ctx,
                                     List<String> args)
        { sb.append("#DummyFunctionCall#");  return sb;}
    @Override public boolean isInvalid() { return true; }
    } /////////// DummyFunction

    /** Handles almost all Astrolog builtin functions */
    static class AstrologFunction extends Function
    {

    AstrologFunction(String funcName, int narg)
    {
        super(funcName, narg);
    }

    @Override
    public AstroMem targetMemSpace()
    {
        return null;
    }

    @Override
    public StringBuilder genFuncCall(
            StringBuilder sb, ExprFuncContext ctx, List<String> args)
    {
        if(Ops.isAnyOp(funcName))
            reportError(FUNC_CASTRO, ctx.fc.id,
                        "using castro operator '%s' as a function",
                        ctx.fc.id.getText());
        sb.append(funcName).append(' ');

        for(String arg : args) {
            sb.append(arg);
        }
        return sb;
    }
    } /////////// AstrologFunction

    /* ************************************************************* */

    /**
     * Record name and number of args.
     * May be replaced by a user function.
     * At the end of pass1 these removed if not converted.
     */
    private static class UnknownFunction extends Function
    {
    private List<FunctionUsage> references = new ArrayList<>();
    public UnknownFunction(Token id, int narg)
    {
        super(id.getText(), narg);
        references.add(new FunctionUsage(id, narg));
    }

    @Override
    public boolean isUnknown() {
        return true;
    }

    @Override
    public boolean isBuiltin() {
        return false;
    };

    @Override
    List<FunctionUsage> getReferences() {
        return Collections.unmodifiableList(references);
    }

    @Override
    public void addReference(Token id, int narg) {
        references.add(new FunctionUsage(id, narg));
    }

    /**
     * Check for correct number of args.
     * UnknownFunction not handled here; just say it's ok.
     */
    @Override
    public boolean checkReportArgs(Func_callContext ctx)
    {
        return true;
    }

    @Override
    public StringBuilder genFuncCall(StringBuilder sb, ExprFuncContext ctx,
                                                           List<String> args)
    {
        throw new IllegalStateException();
    }
    }

    /* ************************************************************* */

    /**
     * A UserFunction is basically a macro.
     * The macro name must be followed by "( ... )", zero or more arguments;
     * otherwise it is a simple macro.
     */
    private static class UserFunction extends Function
    {
    /** The declared argument names are the variables for the user func. */
    // A sorted set, argument declaration order, would be nice.
    private final List<String> argNames;
    
    private UserFunction(String funcName, List<String> argNames)
    {
        super(funcName, argNames.size());

        if(new HashSet<>(argNames).size() != argNames.size())
            throw new IllegalArgumentException();

        this.argNames = List.copyOf(argNames);
    }
    
    @Override
    public boolean isBuiltin()
    {
        return false;
    }

    /**
     * Check for correct number of args.
     * A user function must match narg; no warning.
     * @return true if nargs is OK, else false if bad num args.
     */
    @Override
    public boolean checkReportArgs(Func_callContext ctx)
    {
        if(ctx.args.size() != narg()) {

            reportUserFuncNargError(ctx, ctx.id.getText(), narg(), ctx.args.size());
            return false;
        }
        return true;
    }
    
    /** Assign the arguments to the macro's variables, invoke the macro.
     * Create a list that has the code to initialize macro function arguments;
     * for "m1(a + 13, b + 7)" it looks something like:
     * <br> "= 123 Add @a 13"
     * <br> "= 127 Add @b 7"
     * <br> "Macro 1"
     * <p>
     * Then encapsulate the code into a single Astrolog "DO*" expression.
     */
    @Override
    public StringBuilder genFuncCall(StringBuilder sb, ExprFuncContext ctx,
                                                           List<String> args)
    {
        if(argNames.size() != args.size()) {

            throw new IllegalArgumentException();
        }

        List<String> callMacro = new ArrayList<>();
        Registers regs = lookup(Registers.class);
        // Set up the macro parameters.
        for(int i = 0; i < args.size(); i++) {
            Var var = regs.getVar(argNames.get(i));
            callMacro.add("= " + var.getAddr() + " " + args.get(i));
        }
        // Add the call to invoke the macro.
        Var macro = lookup(Macros.class).getVar(name());
        callMacro.add("Macro " + macro.getAddr() + " ");
        Pass3.appendDo(sb, callMacro, () -> "UserFunctionCall");

        return sb;
    }

    @Override
    public String toString()
    {
        return String.format("UserFunction{name:%s, args:%s}",
                             name(), argNames);
    }
    
    }

    /* ************************************************************* */
    private static class SwitchFunction extends SwitchMacroFunction
    {
    public SwitchFunction() { super("Switch"); }

    @Override public AstroMem targetMemSpace() { return lookup(Switches.class); }
    } /////////// SwitchFunction

    private static class MacroFunction extends SwitchMacroFunction
    {
    public MacroFunction() { super("Macro"); }

    @Override public AstroMem targetMemSpace() { return lookup(Macros.class); }
    } /////////// MacroFunction

    /* ************************************************************* */
    private static abstract class SwitchMacroFunction extends Function
    {

    public SwitchMacroFunction(String name)
    {
        super(name, 1);
    }

    @Override
    public boolean isDoneReportSpecialFuncArgs(Func_callContext ctx)
    {
        return macroSwitchFuncArgs(ctx, targetMemSpace());
    }

    @Override
    public StringBuilder genFuncCall(StringBuilder sb, ExprFuncContext ctx,
                                     List<String> args)
    {
        if(args.size() == 1)
            sb.append(name()).append(' ').append(args.get(0));
        else
            sb.append("#").append(name()).append(":args# ");
        return sb;
    }

    } /////////// SwitchMacroFunction

}
