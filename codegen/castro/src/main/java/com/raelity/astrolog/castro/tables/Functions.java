/* Copyright Â© 2023 Ernie Rael. All rights reserved */

// This file is generated by a script: scipts/extract_functions
// from astrolog's express.cpp which is copyrighted by:
// Walter D. Pullen (Astara@msn.com, http://www.astrolog.org/astrolog.htm)

package com.raelity.astrolog.castro.tables;

import java.util.Collections;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;
import java.util.Objects;

public class Functions
{
public static final String FUNC_ID_SWITCH = "switch";
public static final String FUNC_ID_MACRO = "macro";

public static boolean eqfunc(String s1, String s2)
{
    Objects.nonNull(s1);
    Objects.nonNull(s2);
    return s1.equalsIgnoreCase(s2);
}

public static boolean funcSwitchOrMacro(String funcName)
{
    return eqfunc(FUNC_ID_SWITCH, funcName) || eqfunc(FUNC_ID_MACRO, funcName);
}

/** @return number of arguments for func; null if func does not exist */
public static Integer narg(String funcName)
{
    Info info = functions.funcs.get(funcName.toLowerCase(Locale.ROOT));
    return info != null ? info.narg : null;
}

public static String name(String funcName)
{
    Info info = functions.funcs.get(funcName.toLowerCase(Locale.ROOT));
    return info != null ? info.name : null;
}

/** Convert castro function name to AstroExpression name.
 * This is only used in cases where a name can be replaced without requiring
 * a code rewrite.
 * @return the astro name; if no replacement return the input funcName.
 */
public static String translate(String funcName)
{
    return functions.replaceFuncs.getOrDefault(funcName, name(funcName));
}

// Would like a read only unioun of regular maps and unknown maps.
// https://stackoverflow.com/questions/66428518/java-read-only-view-of-the-union-of-two-maps;
// But, unknown only needs to be a set; since unkown rest of info is derived.

/** Track a special function (unknown or magic);
 * further inquiries about this
 * name will not return null and narg returns 0. 
 * Keep a set of special function names. And add the unknown
 * to the main map to keep the rest of the code simple.
 */
public static void recordCastroFunction(String funcName)
{
    String lc = funcName.toLowerCase(Locale.ROOT);
    if(functions.funcs.containsKey(lc) || functions.unknownFuncs.containsKey(lc))
        throw new IllegalArgumentException(funcName);
    functions.unknownFuncs.put(lc, null);
    functions.add(lc, 0, "R_");
}

public static boolean isCastroFunction(String funcName)
{
    return functions.unknownFuncs.containsKey(funcName.toLowerCase(Locale.ROOT));
}

// singleton
private static final Functions functions = new Functions();

private final Map<String, Info> funcsModifiableMap;
private final Map<String, Info> funcs;
private final Map<String,String> replaceFuncs;
private final Map<String,Object> unknownFuncs;

private Functions() {
    // ~500 items, 700 entries, load-factor .72
    // keep modifiable funcs around to add unknown func.
    this.funcsModifiableMap = new HashMap<>(700);
    this.funcs = Collections.unmodifiableMap(funcsModifiableMap);
    this.unknownFuncs = new HashMap<>();
    this.replaceFuncs = new HashMap<>();
    new AstrologFunctions(this).createEntries();
    // Provide "evaluate both sides" semantics for "?:" if wanted.
    addWithReplacement("QuestColon", "?:", 3, "E_IEE");
    addWithReplacement("AssignObj", "=Obj", 4, "R_IIII");
    addWithReplacement("AssignHou", "=Hou", 4, "R_IIII");
}

private void addWithReplacement(String castroName, String astroName, int narg, String types)
{
    add(castroName, narg, types);
    replaceFuncs.put(castroName, astroName);
}

/** name is the "documented" case */
record Info(String name, int narg){};

/** key is lower case. Save original name and nargs. */
void add(String funcName, int narg, String types)
{
    Objects.nonNull(types);
    funcsModifiableMap.put(funcName.toLowerCase(Locale.ROOT), new Info(funcName, narg));
}

}
