/*
 * Do 
 *      castro mazegame.castro
 *      astrolog -i mazegame.as
 *
 * To use the vi bindings to move around the maze:
 *      castro vi.castro mazegame.castro
 *      astrolog -i vi.as -i mazegame.as
 */
copy {
; This is a port to castro of "mazegame.as" from Astrolog:
; https://github.com/CruiserOne/Astrolog/blob/2676d1c63d22c66513c38f032a189e990ad2011e/mazegame.as
; https://github.com/CruiserOne/Astrolog/blob/master/mazegame.as
}

/*
 * Limit automatic variable allocation, unbounded maze starts at 40.
 * By setting this, there's an error if auto alloc runs out of space.
 */
layout memory { limit 40; }

/*
 * Start switch allocation over the last chunk of function keys.
 * Start at Alt-F1.
 */
layout switch { base 37; }

/** Start macro allocation somewhere random */
layout macro { base 55; }

/*
 * maze is a giant array, far bigger than 2, goes to the end of memory
 *
 * The maze is a square, width/height given by var "c",
 * maze[x + y * c] (maze[x,y], but no 2 dimensional arrays)
 *      0 - a wall
 *      1 - a path
 */
var maze[2] @40;

// There are two sets of keys for navigation, this point to a macro
var nav_ptr; // address of current navigation macro, change by F6

/*
 * Builtin variable usage:
 *
 *      a - left/right current position
 *      b - up/down current position
 *      c - width/height of maze (maze is square)
 *
 *      k - one-shot flag, clear it to give welcome message
 *      l - one-shot flag, clear it to report time and finished message
 */

var navmsgs[2];
run {
    SetString navmsgs[0]
        'Use w/a/s/d keys to move the dot through the Maze to the finish.\n\n'
        'Use h/j/k/l keys to move the dot through the Maze to the finish.\n\n'
}

switch welcome @1 {
    // insure a valid nav_ptr, don't change if already set
    ~1 {
        if ((nav_ptr != MacroAddress(nav_wasd)) & (nav_ptr != MacroAddress(nav_vi)))
            nav_ptr = MacroAddress(nav_wasd);
    }

    cprintf 'Welcome to Astrolog Mazes! (castro):)\n'
    ~1 { x = &navmsgs + (nav_ptr == MacroAddress(nav_wasd) ? 0 : 1); }
    YYT '\x'
    cprintf 'Press F1 to display this help text.\n'
    cprintf 'Press F2 to create new Maze.\n'
    cprintf 'Press F3 to create smaller Maze.\n'
    cprintf 'Press F4 to create larger Maze.\n'
    cprintf 'Press F5 to restart current Maze.\n'
}

// UI function keys
switch new_maze   @2  { -n ~1 { Macro(solid_maze); Macro(create_paths); } }
switch smaller    @3  { ~1 { if (d > 1) d -= 1; Switch(new_maze); } }
switch larger     @4  { ~1 { if (d < 25) d += 1; Switch(new_maze); } }
switch restart    @5  { -n ~1 { a = 1; b = 0; k = 0; } }

// The nav keys are mapped to F6-F9
switch left  { ~1 { a -= 1; if (Macro(z_is_wall)) a += 1; } }
switch right { ~1 { a += 1; if (Macro(z_is_wall)) a -= 1; } }
switch up    { ~1 { b -= 1; if (Macro(z_is_wall)) b += 1; } }
switch down  { ~1 { b += 1; if (Macro(z_is_wall)) b -= 1; } }
switch exit_move  { -n -n1 ~1 { l = 0; } }

switch report_done {
    // 86400 == 24 * 60 * 60 == number of seconds in a day.
    ~1 { u = Int((JulianT() - t) * 8640000.0); x = u / 100; y = Int(u % 100); }
    -YYT 'Congratulations, you made it through the Maze in \X.\Y seconds! :)\n\nHave an a-Maze-ing day! :)\n'

    // Alternately, can use cprintf if willing to use tmp variables
    // ~1 { u = Int((JulianT() - t) * 8640000.0); }
    // // Two args, so %a, %b are used
    // cprintf 'Congratulations, you made it through the Maze in %d.%d seconds! :)\n\n'
    //         {~ u / 100; Int(u % 100); }
    // cprintf 'Have an a-Maze-ing day! :)\n'
}

switch hourglass { _Wh }


macro draw_maze {
    DCol(K_Green);
    for (y = 0; c - 1)
        for (x = 0; c - 1) {
            v = h + x * e;
            w = h + y * e;
            if (!maze[y * c + x])
                DBlock(v - f, w - f, v + f - 1, w + f - 1);
        }
}

macro solid_maze {
    c = d * 2 + 1;
    g = d * d - 1;
    t = k ? JulianT() : Tim();
    s = RndSeed(Fract(t * 10000.0) * 10000.0);
    for (y = 0; c - 1)
        for (x = 0; c - 1)
            maze[y * c + x] = 0;
}

macro create_paths {
    a = 1; b = 1;
    maze[b * c + a] = 1;
    while (g)
        Macro(create_paths_A);
    maze[1] = 1;
    a = c - 2; b = c - 1;
    Macro(z_is_wall);
    *z = 1; // path now at this spot
    a = 1; b = 0;
}

macro create_paths_A {
    r = Rnd(0, 3);
    x = a; y = b;
    if (Odd(r)) {
        x += r <= 1 ? 2 : -2;
    } else {
        y += r <= 0 ? 2 : -2;
    }
    if (Tween(x, 0, c - 1) & Tween(y, 0, c - 1))
        Macro(create_paths_B);
}

macro create_paths_B {
    z = &maze + y * c + x;
    if (!*z) { // a wall
        *z = 1; // clear the wall
        maze[((y + b) >> 1) * c + ((x + a) >> 1)] = 1;
        g -= 1;
    }
    a = x; b = y;
}

/*
 * Check if a,b position is a wall
 *
 * SideEffect: z is set to &maze[a,b]
 * Return True if z position is a wall.
 */
macro z_is_wall {
    if (b >= c)
        Switch(exit_move);
    z = &maze + (b < 0 ? 0 : b * c + a);
    !*z;
}

// TODO: use cascading ?:
macro nav_wasd {
    if (z == CharC('w')) z = FK_F0 + SAddr(up);      // w --> up
    if (z == CharC('a')) z = FK_F0 + SAddr(left);    // a --> left
    if (z == CharC('s')) z = FK_F0 + SAddr(down);    // s --> down
    if (z == CharC('d')) z = FK_F0 + SAddr(right);   // d --> right
}

// hjkl are the vi/vim navigation keys
// TODO: use cascading ?:
macro nav_vi {
    if (z == CharC('k')) z = FK_F0 + SAddr(up);      // k --> up
    if (z == CharC('h')) z = FK_F0 + SAddr(left);    // h --> left
    if (z == CharC('j')) z = FK_F0 + SAddr(down);    // j --> down
    if (z == CharC('l')) z = FK_F0 + SAddr(right);   // l --> right
}

run {
    ~Q2 {
        f = (Min(_Xwx(), _Xwy()) - 1) / (d * 12) + 1;
        e = f * 2;
        h = (Min(_Xwx(), _Xwy()) - (c - 1) * e) / 2;
        // draw "my" position
        DCol(K_Red);
        v = h + a * e;
        w = h + b * e;
        DDisk(v - f, w - f, v + f - 1, w + f - 1);
        Macro(draw_maze);
    }
}
run {
    ~Q3 {
        if (!k) {
            k = 1;
            Switch(welcome);
            t = JulianT();
        }
        if (!l) {
            l = 1;
            Switch(report_done);
        }
    }
}

run { ~XQ { Macro(+nav_ptr); } }

run {
    ~WQ {
        if (z == 40082) z = 40152;
        if (z == 40131) z = 40150;
        if (z == 40281) z = 40153;
        if (z == 40086) z = 40151;
    }
}

run {
    ~1 { d = 10; f = 5; l = 1; if (WIN()) Switch(hourglass); }
    =b0 =Xe
    ~1 { Switch(new_maze); }
}
